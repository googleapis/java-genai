/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Auto-generated code. Do not edit.

package com.google.genai.types;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.google.auto.value.AutoValue;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.genai.JsonSerializable;
import java.util.Optional;

/**
 * Incremental server update generated by the model in response to client messages.
 *
 * <p>Content is generated as quickly as possible, and not in real time. Clients may choose to
 * buffer and play it out in real time.
 */
@AutoValue
@JsonDeserialize(builder = LiveServerContent.Builder.class)
public abstract class LiveServerContent extends JsonSerializable {
  /** The content that the model has generated as part of the current conversation with the user. */
  @JsonProperty("modelTurn")
  public abstract Optional<Content> modelTurn();

  /**
   * If true, indicates that the model is done generating. Generation will only start in response to
   * additional client messages. Can be set alongside `content`, indicating that the `content` is
   * the last in the turn.
   */
  @JsonProperty("turnComplete")
  public abstract Optional<Boolean> turnComplete();

  /**
   * If true, indicates that a client message has interrupted current model generation. If the
   * client is playing out the content in realtime, this is a good signal to stop and empty the
   * current queue.
   */
  @JsonProperty("interrupted")
  public abstract Optional<Boolean> interrupted();

  /** Metadata returned to client when grounding is enabled. */
  @JsonProperty("groundingMetadata")
  public abstract Optional<GroundingMetadata> groundingMetadata();

  /**
   * If true, indicates that the model is done generating. When model is interrupted while
   * generating there will be no generation_complete message in interrupted turn, it will go through
   * interrupted > turn_complete. When model assumes realtime playback there will be delay between
   * generation_complete and turn_complete that is caused by model waiting for playback to finish.
   * If true, indicates that the model has finished generating all content. This is a signal to the
   * client that it can stop sending messages.
   */
  @JsonProperty("generationComplete")
  public abstract Optional<Boolean> generationComplete();

  /**
   * Input transcription. The transcription is independent to the model turn which means it doesn’t
   * imply any ordering between transcription and model turn.
   */
  @JsonProperty("inputTranscription")
  public abstract Optional<Transcription> inputTranscription();

  /**
   * Output transcription. The transcription is independent to the model turn which means it doesn’t
   * imply any ordering between transcription and model turn.
   */
  @JsonProperty("outputTranscription")
  public abstract Optional<Transcription> outputTranscription();

  /** Metadata related to url context retrieval tool. */
  @JsonProperty("urlContextMetadata")
  public abstract Optional<UrlContextMetadata> urlContextMetadata();

  /** Reason for the turn is complete. */
  @JsonProperty("turnCompleteReason")
  public abstract Optional<TurnCompleteReason> turnCompleteReason();

  /**
   * If true, indicates that the model is not generating content because it is waiting for more
   * input from the user, e.g. because it expects the user to continue talking.
   */
  @JsonProperty("waitingForInput")
  public abstract Optional<Boolean> waitingForInput();

  /** Instantiates a builder for LiveServerContent. */
  @ExcludeFromGeneratedCoverageReport
  public static Builder builder() {
    return new AutoValue_LiveServerContent.Builder();
  }

  /** Creates a builder with the same values as this instance. */
  public abstract Builder toBuilder();

  /** Builder for LiveServerContent. */
  @AutoValue.Builder
  public abstract static class Builder {
    /** For internal usage. Please use `LiveServerContent.builder()` for instantiation. */
    @JsonCreator
    private static Builder create() {
      return new AutoValue_LiveServerContent.Builder();
    }

    /**
     * Setter for modelTurn.
     *
     * <p>modelTurn: The content that the model has generated as part of the current conversation
     * with the user.
     */
    @JsonProperty("modelTurn")
    public abstract Builder modelTurn(Content modelTurn);

    /**
     * Setter for modelTurn builder.
     *
     * <p>modelTurn: The content that the model has generated as part of the current conversation
     * with the user.
     */
    @CanIgnoreReturnValue
    public Builder modelTurn(Content.Builder modelTurnBuilder) {
      return modelTurn(modelTurnBuilder.build());
    }

    @ExcludeFromGeneratedCoverageReport
    abstract Builder modelTurn(Optional<Content> modelTurn);

    /** Clears the value of modelTurn field. */
    @ExcludeFromGeneratedCoverageReport
    @CanIgnoreReturnValue
    public Builder clearModelTurn() {
      return modelTurn(Optional.empty());
    }

    /**
     * Setter for turnComplete.
     *
     * <p>turnComplete: If true, indicates that the model is done generating. Generation will only
     * start in response to additional client messages. Can be set alongside `content`, indicating
     * that the `content` is the last in the turn.
     */
    @JsonProperty("turnComplete")
    public abstract Builder turnComplete(boolean turnComplete);

    @ExcludeFromGeneratedCoverageReport
    abstract Builder turnComplete(Optional<Boolean> turnComplete);

    /** Clears the value of turnComplete field. */
    @ExcludeFromGeneratedCoverageReport
    @CanIgnoreReturnValue
    public Builder clearTurnComplete() {
      return turnComplete(Optional.empty());
    }

    /**
     * Setter for interrupted.
     *
     * <p>interrupted: If true, indicates that a client message has interrupted current model
     * generation. If the client is playing out the content in realtime, this is a good signal to
     * stop and empty the current queue.
     */
    @JsonProperty("interrupted")
    public abstract Builder interrupted(boolean interrupted);

    @ExcludeFromGeneratedCoverageReport
    abstract Builder interrupted(Optional<Boolean> interrupted);

    /** Clears the value of interrupted field. */
    @ExcludeFromGeneratedCoverageReport
    @CanIgnoreReturnValue
    public Builder clearInterrupted() {
      return interrupted(Optional.empty());
    }

    /**
     * Setter for groundingMetadata.
     *
     * <p>groundingMetadata: Metadata returned to client when grounding is enabled.
     */
    @JsonProperty("groundingMetadata")
    public abstract Builder groundingMetadata(GroundingMetadata groundingMetadata);

    /**
     * Setter for groundingMetadata builder.
     *
     * <p>groundingMetadata: Metadata returned to client when grounding is enabled.
     */
    @CanIgnoreReturnValue
    public Builder groundingMetadata(GroundingMetadata.Builder groundingMetadataBuilder) {
      return groundingMetadata(groundingMetadataBuilder.build());
    }

    @ExcludeFromGeneratedCoverageReport
    abstract Builder groundingMetadata(Optional<GroundingMetadata> groundingMetadata);

    /** Clears the value of groundingMetadata field. */
    @ExcludeFromGeneratedCoverageReport
    @CanIgnoreReturnValue
    public Builder clearGroundingMetadata() {
      return groundingMetadata(Optional.empty());
    }

    /**
     * Setter for generationComplete.
     *
     * <p>generationComplete: If true, indicates that the model is done generating. When model is
     * interrupted while generating there will be no generation_complete message in interrupted
     * turn, it will go through interrupted > turn_complete. When model assumes realtime playback
     * there will be delay between generation_complete and turn_complete that is caused by model
     * waiting for playback to finish. If true, indicates that the model has finished generating all
     * content. This is a signal to the client that it can stop sending messages.
     */
    @JsonProperty("generationComplete")
    public abstract Builder generationComplete(boolean generationComplete);

    @ExcludeFromGeneratedCoverageReport
    abstract Builder generationComplete(Optional<Boolean> generationComplete);

    /** Clears the value of generationComplete field. */
    @ExcludeFromGeneratedCoverageReport
    @CanIgnoreReturnValue
    public Builder clearGenerationComplete() {
      return generationComplete(Optional.empty());
    }

    /**
     * Setter for inputTranscription.
     *
     * <p>inputTranscription: Input transcription. The transcription is independent to the model
     * turn which means it doesn’t imply any ordering between transcription and model turn.
     */
    @JsonProperty("inputTranscription")
    public abstract Builder inputTranscription(Transcription inputTranscription);

    /**
     * Setter for inputTranscription builder.
     *
     * <p>inputTranscription: Input transcription. The transcription is independent to the model
     * turn which means it doesn’t imply any ordering between transcription and model turn.
     */
    @CanIgnoreReturnValue
    public Builder inputTranscription(Transcription.Builder inputTranscriptionBuilder) {
      return inputTranscription(inputTranscriptionBuilder.build());
    }

    @ExcludeFromGeneratedCoverageReport
    abstract Builder inputTranscription(Optional<Transcription> inputTranscription);

    /** Clears the value of inputTranscription field. */
    @ExcludeFromGeneratedCoverageReport
    @CanIgnoreReturnValue
    public Builder clearInputTranscription() {
      return inputTranscription(Optional.empty());
    }

    /**
     * Setter for outputTranscription.
     *
     * <p>outputTranscription: Output transcription. The transcription is independent to the model
     * turn which means it doesn’t imply any ordering between transcription and model turn.
     */
    @JsonProperty("outputTranscription")
    public abstract Builder outputTranscription(Transcription outputTranscription);

    /**
     * Setter for outputTranscription builder.
     *
     * <p>outputTranscription: Output transcription. The transcription is independent to the model
     * turn which means it doesn’t imply any ordering between transcription and model turn.
     */
    @CanIgnoreReturnValue
    public Builder outputTranscription(Transcription.Builder outputTranscriptionBuilder) {
      return outputTranscription(outputTranscriptionBuilder.build());
    }

    @ExcludeFromGeneratedCoverageReport
    abstract Builder outputTranscription(Optional<Transcription> outputTranscription);

    /** Clears the value of outputTranscription field. */
    @ExcludeFromGeneratedCoverageReport
    @CanIgnoreReturnValue
    public Builder clearOutputTranscription() {
      return outputTranscription(Optional.empty());
    }

    /**
     * Setter for urlContextMetadata.
     *
     * <p>urlContextMetadata: Metadata related to url context retrieval tool.
     */
    @JsonProperty("urlContextMetadata")
    public abstract Builder urlContextMetadata(UrlContextMetadata urlContextMetadata);

    /**
     * Setter for urlContextMetadata builder.
     *
     * <p>urlContextMetadata: Metadata related to url context retrieval tool.
     */
    @CanIgnoreReturnValue
    public Builder urlContextMetadata(UrlContextMetadata.Builder urlContextMetadataBuilder) {
      return urlContextMetadata(urlContextMetadataBuilder.build());
    }

    @ExcludeFromGeneratedCoverageReport
    abstract Builder urlContextMetadata(Optional<UrlContextMetadata> urlContextMetadata);

    /** Clears the value of urlContextMetadata field. */
    @ExcludeFromGeneratedCoverageReport
    @CanIgnoreReturnValue
    public Builder clearUrlContextMetadata() {
      return urlContextMetadata(Optional.empty());
    }

    /**
     * Setter for turnCompleteReason.
     *
     * <p>turnCompleteReason: Reason for the turn is complete.
     */
    @JsonProperty("turnCompleteReason")
    public abstract Builder turnCompleteReason(TurnCompleteReason turnCompleteReason);

    @ExcludeFromGeneratedCoverageReport
    abstract Builder turnCompleteReason(Optional<TurnCompleteReason> turnCompleteReason);

    /** Clears the value of turnCompleteReason field. */
    @ExcludeFromGeneratedCoverageReport
    @CanIgnoreReturnValue
    public Builder clearTurnCompleteReason() {
      return turnCompleteReason(Optional.empty());
    }

    /**
     * Setter for turnCompleteReason given a known enum.
     *
     * <p>turnCompleteReason: Reason for the turn is complete.
     */
    @CanIgnoreReturnValue
    public Builder turnCompleteReason(TurnCompleteReason.Known knownType) {
      return turnCompleteReason(new TurnCompleteReason(knownType));
    }

    /**
     * Setter for turnCompleteReason given a string.
     *
     * <p>turnCompleteReason: Reason for the turn is complete.
     */
    @CanIgnoreReturnValue
    public Builder turnCompleteReason(String turnCompleteReason) {
      return turnCompleteReason(new TurnCompleteReason(turnCompleteReason));
    }

    /**
     * Setter for waitingForInput.
     *
     * <p>waitingForInput: If true, indicates that the model is not generating content because it is
     * waiting for more input from the user, e.g. because it expects the user to continue talking.
     */
    @JsonProperty("waitingForInput")
    public abstract Builder waitingForInput(boolean waitingForInput);

    @ExcludeFromGeneratedCoverageReport
    abstract Builder waitingForInput(Optional<Boolean> waitingForInput);

    /** Clears the value of waitingForInput field. */
    @ExcludeFromGeneratedCoverageReport
    @CanIgnoreReturnValue
    public Builder clearWaitingForInput() {
      return waitingForInput(Optional.empty());
    }

    public abstract LiveServerContent build();
  }

  /** Deserializes a JSON string to a LiveServerContent object. */
  @ExcludeFromGeneratedCoverageReport
  public static LiveServerContent fromJson(String jsonString) {
    return JsonSerializable.fromJsonString(jsonString, LiveServerContent.class);
  }
}
